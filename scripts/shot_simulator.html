<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FRC Ball Shooter Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        .overlay {
            position: fixed;
            color: white;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 20px;
            backdrop-filter: blur(4px);
        }

        #top-bar {
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        #top-bar .title {
            font-weight: 600;
            font-size: 18px;
        }

        #sidebar {
            position: fixed;
            top: 60px;
            left: 0;
            width: 280px;
            height: calc(100vh - 60px);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            padding: 20px;
            overflow-y: auto;
            color: white;
            font-size: 13px;
        }

        .section {
            margin-bottom: 24px;
        }

        .section-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 12px;
            color: #ffaa00;
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-label {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            color: #ccc;
        }

        .slider-container {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        input[type="range"] {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ffaa00;
            cursor: pointer;
        }

        .value-display {
            min-width: 60px;
            text-align: right;
            font-family: 'Consolas', monospace;
            color: #fff;
        }

        input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
        }

        button {
            background: rgba(255, 170, 0, 0.3);
            border: 1px solid rgba(255, 170, 0, 0.6);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            transition: background 0.2s;
            width: 100%;
        }

        button:hover {
            background: rgba(255, 170, 0, 0.5);
        }

        button:active {
            background: rgba(255, 170, 0, 0.7);
        }

        .info-line {
            font-family: 'Consolas', monospace;
            font-size: 12px;
            margin-bottom: 6px;
            color: #ddd;
        }

        .manual-controls.disabled {
            opacity: 0.45;
        }

        .manual-controls input[type="range"]:disabled {
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .debug-block {
            font-family: 'Consolas', monospace;
            font-size: 11px;
            line-height: 1.35;
            color: #cfe8ff;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 4px;
            padding: 8px;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }

        .status-dot.hit {
            background: #00cc44;
            box-shadow: 0 0 10px #00cc44;
        }

        .status-dot.miss {
            background: #cc2200;
            box-shadow: 0 0 10px #cc2200;
        }

        .status-dot.neutral {
            background: #2da44e;
            box-shadow: 0 0 8px #2da44e;
        }

        .controls-help {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 11px;
            color: #aaa;
        }

        #test-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1a1a1a;
            color: white;
            padding: 40px;
            overflow-y: auto;
            display: none;
        }

        #test-panel h1 {
            margin-bottom: 20px;
        }

        .test-result {
            margin-bottom: 16px;
            padding: 12px;
            border-left: 4px solid #666;
            background: rgba(255, 255, 255, 0.05);
        }

        .test-result.pass {
            border-left-color: #00cc44;
        }

        .test-result.fail {
            border-left-color: #cc2200;
        }

        .test-name {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .test-details {
            font-family: 'Consolas', monospace;
            font-size: 11px;
            color: #aaa;
        }

        .test-summary {
            margin-top: 30px;
            font-size: 18px;
            font-weight: 600;
        }

        .miss-reason {
            font-size: 11px;
            color: #ff6666;
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="top-bar" class="overlay">
        <div class="title">FRC Ball Shooter Simulator</div>
        <div id="hit-status" class="status-indicator">
            <span class="status-dot neutral"></span>
            <span id="status-text">Ready</span>
        </div>
    </div>

    <div id="sidebar">
        <div class="section manual-controls" id="manual-controls-section">
            <div class="section-title">Manual Controls</div>
            <div class="control-group">
                <label class="control-label">Velocity (m/s)</label>
                <div class="slider-container">
                    <input type="range" id="velocity-slider" min="5" max="25" step="0.1" value="15.0">
                    <span class="value-display" id="velocity-value">15.0</span>
                </div>
            </div>
            <div class="control-group">
                <label class="control-label">Elevation (deg)</label>
                <div class="slider-container">
                    <input type="range" id="elevation-slider" min="10" max="80" step="0.5" value="45.0">
                    <span class="value-display" id="elevation-value">45.0</span>
                </div>
            </div>
            <div class="control-group">
                <label class="control-label">Azimuth (deg, rel. to hub)</label>
                <div class="slider-container">
                    <input type="range" id="azimuth-slider" min="-90" max="90" step="0.5" value="0.0">
                    <span class="value-display" id="azimuth-value">0.0</span>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Move-and-Shoot</div>
            <div class="control-group">
                <label class="control-label">Robot Vx (m/s)</label>
                <div class="slider-container">
                    <input type="range" id="robot-vx-slider" min="-1" max="1" step="0.1" value="0.1">
                    <span class="value-display" id="robot-vx-value">0.1</span>
                </div>
            </div>
            <div class="control-group">
                <label class="control-label">Robot Vy (m/s)</label>
                <div class="slider-container">
                    <input type="range" id="robot-vy-slider" min="-1" max="1" step="0.1" value="0.1">
                    <span class="value-display" id="robot-vy-value">0.1</span>
                </div>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="velocity-motion-checkbox">
                    Enable Velocity Motion
                </label>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="wall-reflection-checkbox" checked>
                    Wall Reflection
                </label>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="autoshoot-checkbox">
                    AutoShoot (ShooterUtils)
                </label>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Physics</div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="air-resistance-checkbox" checked>
                    Air Resistance
                </label>
            </div>
            <div class="control-group">
                <label class="control-label">Drag Coefficient</label>
                <div class="slider-container">
                    <input type="range" id="drag-coeff-slider" min="0.1" max="1.0" step="0.01" value="0.47">
                    <span class="value-display" id="drag-coeff-value">0.47</span>
                </div>
            </div>
            <div class="control-group">
                <label class="control-label">Ball Mass (kg)</label>
                <div class="slider-container">
                    <input type="range" id="ball-mass-slider" min="0.1" max="0.5" step="0.005" value="0.215">
                    <span class="value-display" id="ball-mass-value">0.215</span>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Robot Info</div>
            <div class="info-line">Position: (<span id="robot-x">--</span>, <span id="robot-y">--</span>) m</div>
            <div class="info-line">Velocity: (<span id="robot-vx">--</span>, <span id="robot-vy">--</span>) m/s</div>
            <div class="info-line">Distance: <span id="optimal-distance">--</span> m</div>
            <div class="info-line">Bearing: <span id="optimal-bearing">--</span> deg</div>
            <div class="info-line">Shot Mode: <span id="shot-mode">Manual</span></div>
            <div class="info-line">Shots: <span id="shot-counter">0/0 (0%)</span></div>
            <div id="miss-reason-display" class="miss-reason"></div>
        </div>

        <div class="section">
            <div class="section-title">AutoShoot Debug</div>
            <div id="autoshoot-debug" class="debug-block">AutoShoot disabled.</div>
        </div>

        <div class="section">
            <div class="section-title">Controls</div>
            <div class="info-line">WASD/Arrows: Move robot (manual mode)</div>
            <div class="info-line">Space: Fire shot (auto if enabled)</div>
            <div class="info-line">R: Reset position</div>
        </div>

    </div>

    <div id="test-panel">
        <h1>Physics Test Results</h1>
        <div id="test-results"></div>
        <div class="test-summary" id="test-summary"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // High-level architecture:
        // 1) Command layer:
        //    - Manual mode uses velocity/elevation/azimuth sliders.
        //    - AutoShoot mode uses ShooterUtils-ported solve with velocity lead compensation.
        // 2) Physics layer:
        //    - computeTrajectory3DMoving() integrates 3D flight with optional drag and robot
        //      velocity inheritance, then evaluates hub entry/wall collisions.
        // 3) Presentation layer:
        //    - updatePreview() redraws the predicted path and robot aiming pose.
        //    - fireShot() animates a sampled trajectory and updates hit/miss stats.
        // 4) Runtime loop:
        //    - animate() advances robot motion (manual or velocity+bounce), refreshes preview,
        //      and renders the scene.
        // 5) Validation mode:
        //    - ?test=1 runs physics regression tests from physics_test_data.json.

        // ==================== CONSTANTS ====================
        const GRAVITY = 9.81;
        const AIR_DENSITY = 1.225;
        const DRAG_COEFFICIENT_DEFAULT = 0.47;
        const BALL_MASS_DEFAULT = 0.215;
        const FIELD_LENGTH = 16.5;
        const FIELD_WIDTH = 8.2;
        const ALLIANCE_ZONE_DEPTH = 4.03;
        const ALLIANCE_ZONE_WIDTH = 8.07;
        const HUB_DISTANCE_FROM_WALL = 4.03;
        const HUB_OPENING_HEIGHT = 1.83;
        const HUB_OPENING_WIDTH = 1.06;
        const HUB_OPENING_HALF_WIDTH = 0.53;
        const BALL_DIAMETER = 0.150;
        const BALL_RADIUS = 0.075;
        const LAUNCH_HEIGHT = 0.5;
        const HUB_ENTRY_MIN = HUB_OPENING_HEIGHT + BALL_RADIUS;
        const HUB_X = HUB_DISTANCE_FROM_WALL;
        const HUB_Y = ALLIANCE_ZONE_WIDTH / 2;

        const SHOOTER_MIN_LAUNCH_SPEED = 5.0;
        const SHOOTER_MAX_LAUNCH_SPEED = 15.0;
        const SHOOTER_MIN_ANGLE = 60.0;
        const SHOOTER_MAX_ANGLE = 80.0;
        const MAX_DISTANCE_TO_HUB = 9.2;
        const DELTA_Z = HUB_OPENING_HEIGHT - LAUNCH_HEIGHT;

        let state = null;

        // ==================== PHYSICS ENGINE ====================

        // Shared hit check used by 2D helper tests.
        function checkHubEntry(height, vy) {
            if (vy >= 0) {
                const miss_distance = Math.abs(height - HUB_ENTRY_MIN) + 1.0;
                return { hit: false, miss_distance };
            }

            if (height >= HUB_ENTRY_MIN) {
                return { hit: true, miss_distance: 0.0 };
            }

            const miss_distance = HUB_ENTRY_MIN - height;
            return { hit: false, miss_distance };
        }

        // 2D trajectory integrator used for unit-test parity and angle solving.
        function computeTrajectory2D(velocity, angle, target_distance, dt = 0.001, air_resistance = false, drag_coeff = DRAG_COEFFICIENT_DEFAULT, ball_mass = BALL_MASS_DEFAULT) {
            let vx = velocity * Math.cos(angle);
            let vy = velocity * Math.sin(angle);
            let x = 0.0;
            let y = LAUNCH_HEIGHT;

            let drag_k = 0;
            if (air_resistance) {
                const cross_section = Math.PI * BALL_RADIUS * BALL_RADIUS;
                drag_k = 0.5 * AIR_DENSITY * drag_coeff * cross_section / ball_mass;
            }

            const xs = [x];
            const ys = [y];
            const vys = [vy];

            let height_at_target = null;
            let vy_at_target = null;

            const max_sim_time = 10.0;
            let sim_time = 0.0;
            let prev_x = x;
            let prev_y = y;
            let prev_vy = vy;

            while (y >= 0 && sim_time < max_sim_time) {
                if (air_resistance) {
                    const v_mag = Math.sqrt(vx * vx + vy * vy);
                    let ax_drag = 0, ay_drag = 0;
                    if (v_mag > 0) {
                        ax_drag = -drag_k * v_mag * vx;
                        ay_drag = -drag_k * v_mag * vy;
                    }
                    vx += ax_drag * dt;
                    vy += (ay_drag - GRAVITY) * dt;
                    x += vx * dt;
                    y += vy * dt;
                } else {
                    x += vx * dt;
                    y += vy * dt - 0.5 * GRAVITY * dt * dt;
                    vy -= GRAVITY * dt;
                }

                if (prev_x < target_distance && x >= target_distance && height_at_target === null) {
                    if (vx > 0) {
                        const t_cross = (target_distance - prev_x) / vx;
                        if (air_resistance) {
                            height_at_target = prev_y + prev_vy * t_cross;
                            vy_at_target = prev_vy + (vy - prev_vy) * (t_cross / dt);
                        } else {
                            height_at_target = prev_y + prev_vy * t_cross - 0.5 * GRAVITY * t_cross * t_cross;
                            vy_at_target = prev_vy - GRAVITY * t_cross;
                        }
                    } else {
                        height_at_target = prev_y;
                        vy_at_target = prev_vy;
                    }
                }

                sim_time += dt;
                prev_x = x;
                prev_y = y;
                prev_vy = vy;

                xs.push(x);
                ys.push(y);
                vys.push(vy);
            }

            if (height_at_target === null) {
                const max_reach = xs[xs.length - 1];
                if (max_reach < target_distance) {
                    height_at_target = 0.0;
                    vy_at_target = -Math.abs(vys[vys.length - 1]);
                } else {
                    height_at_target = ys[ys.length - 1];
                    vy_at_target = vys[vys.length - 1];
                }
            }

            const { hit, miss_distance } = checkHubEntry(height_at_target, vy_at_target);

            return {
                hit,
                height_at_target,
                velocity_y_at_target: vy_at_target,
                miss_distance,
                trajectory_x: xs,
                trajectory_y: ys
            };
        }

        // Used by test runner only — analytical solution (no air resistance).
        function computeOptimalAngle(velocity, target_distance) {
            const delta_y = HUB_OPENING_HEIGHT - LAUNCH_HEIGHT;
            const g = GRAVITY;
            const d = target_distance;
            const v = velocity;
            const v2 = v * v;

            const a_coeff = (g * d * d) / (2 * v2);
            const b_coeff = -d;
            const c_coeff = delta_y + (g * d * d) / (2 * v2);

            const discriminant = b_coeff * b_coeff - 4 * a_coeff * c_coeff;

            if (discriminant < 0) {
                return { angle_deg: null, reachable: false };
            }

            const sqrt_disc = Math.sqrt(discriminant);
            const tan_theta_1 = (-b_coeff + sqrt_disc) / (2 * a_coeff);
            const tan_theta_2 = (-b_coeff - sqrt_disc) / (2 * a_coeff);

            const angles = [];
            for (const tan_theta of [tan_theta_1, tan_theta_2]) {
                if (tan_theta > 0) {
                    const angle = Math.atan(tan_theta);
                    if (angle > 0 && angle < Math.PI / 2) {
                        angles.push(angle);
                    }
                }
            }

            angles.sort();

            for (const angle of angles) {
                const result = computeTrajectory2D(velocity, angle, target_distance, 0.001, false);
                if (result.velocity_y_at_target < 0) {
                    return { angle_deg: angle * 180 / Math.PI, reachable: true };
                }
            }
            return { angle_deg: null, reachable: false };
        }

        // Main simulator physics path:
        // 3D ballistic integration + moving-robot velocity inheritance + hub wall/top-entry checks.
        function computeTrajectory3DMoving(
            launch_velocity,
            elevation,
            azimuth,
            target_distance,
            target_bearing,
            robot_vx = 0.0,
            robot_vy = 0.0,
            dt = 0.001,
            air_resistance = false,
            drag_coeff = DRAG_COEFFICIENT_DEFAULT,
            ball_mass = BALL_MASS_DEFAULT
        ) {
            const v_horiz = launch_velocity * Math.cos(elevation);
            let vz = launch_velocity * Math.sin(elevation);

            let vx = v_horiz * Math.cos(azimuth) + robot_vx;
            let vy = v_horiz * Math.sin(azimuth) + robot_vy;

            let x = 0.0;
            let y = 0.0;
            let z = LAUNCH_HEIGHT;

            let drag_k = 0;
            if (air_resistance) {
                const cross_section = Math.PI * BALL_RADIUS * BALL_RADIUS;
                drag_k = 0.5 * AIR_DENSITY * drag_coeff * cross_section / ball_mass;
            }

            const xs = [x];
            const ys = [y];
            const zs = [z];

            const cos_b = Math.cos(target_bearing);
            const sin_b = Math.sin(target_bearing);

            const hub_x_rel = target_distance * cos_b;
            const hub_y_rel = target_distance * sin_b;

            let height_at_target = null;
            let vz_at_target = null;
            let lateral_at_target = null;

            let wall_collision = false;
            let inside_radius = false;
            let descending_cross_x = null;
            let descending_cross_y = null;

            let prev_d_along = 0.0;
            let prev_x = x, prev_y = y, prev_z = z, prev_vz = vz;

            const max_time = 5.0;
            let t = 0.0;

            while (t < max_time && z >= 0) {
                if (air_resistance) {
                    const v_mag = Math.sqrt(vx * vx + vy * vy + vz * vz);
                    let ax = 0, ay = 0, az = -GRAVITY;
                    if (v_mag > 0) {
                        ax = -drag_k * v_mag * vx;
                        ay = -drag_k * v_mag * vy;
                        az = -drag_k * v_mag * vz - GRAVITY;
                    }
                    vx += ax * dt;
                    vy += ay * dt;
                    vz += az * dt;
                } else {
                    vz -= GRAVITY * dt;
                }

                x += vx * dt;
                y += vy * dt;
                z += vz * dt;
                t += dt;

                const d_along = x * cos_b + y * sin_b;

                if (prev_d_along < target_distance && d_along >= target_distance && height_at_target === null) {
                    const frac = (d_along > prev_d_along) ? (target_distance - prev_d_along) / (d_along - prev_d_along) : 0.0;
                    height_at_target = prev_z + frac * (z - prev_z);
                    vz_at_target = prev_vz + frac * (vz - prev_vz);
                    const cross_x = prev_x + frac * (x - prev_x);
                    const cross_y = prev_y + frac * (y - prev_y);
                    lateral_at_target = -cross_x * sin_b + cross_y * cos_b;
                }

                const dx_hub = x - hub_x_rel;
                const dy_hub = y - hub_y_rel;
                const dist_from_hub = Math.sqrt(dx_hub * dx_hub + dy_hub * dy_hub);
                const currently_inside = dist_from_hub <= HUB_OPENING_HALF_WIDTH;

                if (!inside_radius && currently_inside) {
                    if (z < HUB_OPENING_HEIGHT) {
                        wall_collision = true;
                    }
                    inside_radius = true;
                } else if (inside_radius && !currently_inside) {
                    inside_radius = false;
                }

                if (descending_cross_x === null && prev_z >= HUB_OPENING_HEIGHT && z < HUB_OPENING_HEIGHT) {
                    const dz = prev_z - z;
                    const frac_h = (dz > 0) ? (prev_z - HUB_OPENING_HEIGHT) / dz : 0.0;
                    descending_cross_x = prev_x + frac_h * (x - prev_x);
                    descending_cross_y = prev_y + frac_h * (y - prev_y);
                }

                prev_d_along = d_along;
                prev_x = x;
                prev_y = y;
                prev_z = z;
                prev_vz = vz;

                xs.push(x);
                ys.push(y);
                zs.push(z);
            }

            if (height_at_target === null) {
                height_at_target = 0.0;
                vz_at_target = (vz !== 0) ? -Math.abs(vz) : -1.0;
                lateral_at_target = 0.0;
            }

            const effective_radius = HUB_OPENING_HALF_WIDTH - BALL_RADIUS;

            let hit = false;
            let lateral_miss_dist = 0.0;
            let total_miss_distance = 0.0;
            let center_distance = 0.0;
            let vertical_miss = 0.0;
            let lateral_offset = lateral_at_target !== null ? lateral_at_target : 0.0;
            let miss_reason = '';

            if (wall_collision) {
                hit = false;
                lateral_miss_dist = 0.0;
                total_miss_distance = 1.0;
                center_distance = 0.0;
                vertical_miss = 0.0;
                miss_reason = 'Wall collision (entered hub from side)';
            } else if (descending_cross_x !== null) {
                const dx_hub = descending_cross_x - hub_x_rel;
                const dy_hub = descending_cross_y - hub_y_rel;
                const landing_dist = Math.sqrt(dx_hub * dx_hub + dy_hub * dy_hub);

                if (landing_dist <= effective_radius) {
                    hit = true;
                    lateral_miss_dist = 0.0;
                    total_miss_distance = 0.0;
                    miss_reason = '';
                } else {
                    hit = false;
                    lateral_miss_dist = landing_dist - effective_radius;
                    total_miss_distance = lateral_miss_dist;
                    miss_reason = `Lateral miss: ${(lateral_miss_dist * 100).toFixed(1)}cm outside opening`;
                }

                center_distance = landing_dist;
                vertical_miss = 0.0;
                lateral_offset = -descending_cross_x * sin_b + descending_cross_y * cos_b;
            } else {
                hit = false;
                const max_height = Math.max(...zs);
                vertical_miss = Math.max(0.0, HUB_ENTRY_MIN - max_height);
                lateral_miss_dist = 0.0;
                total_miss_distance = vertical_miss + 1.0;
                center_distance = total_miss_distance;
                miss_reason = `Too low: max height ${max_height.toFixed(2)}m < ${HUB_ENTRY_MIN.toFixed(2)}m required`;
            }

            return {
                hit,
                height_at_target,
                velocity_z_at_target: vz_at_target,
                lateral_offset,
                vertical_miss,
                lateral_miss: lateral_miss_dist,
                total_miss_distance,
                center_distance,
                trajectory_x: xs,
                trajectory_y: ys,
                trajectory_z: zs,
                miss_reason
            };
        }

        function clamp(value, minValue, maxValue) {
            return Math.max(minValue, Math.min(maxValue, value));
        }

        // ==================== AUTOSHOOT (PORTED FROM ShooterUtils.java) ====================
        // These helpers mirror the Java autoshoot routine but keep JS-safe math and guardrails.

        // Port of ShooterUtils.getLaunchSpeed(totalHubDist)
        function getLaunchSpeedShooterUtils(totalHubDist) {
            const ratio = clamp(totalHubDist / MAX_DISTANCE_TO_HUB, 0.0, 1.0);
            return SHOOTER_MIN_LAUNCH_SPEED
                + (SHOOTER_MAX_LAUNCH_SPEED - SHOOTER_MIN_LAUNCH_SPEED) * ratio;
        }

        // Port of ShooterUtils.getInitialHoodAngle(totalHubDist, shooterLaunchSpeed)
        // Solves the ballistic quadratic for tan(theta) and selects a valid upward arc.
        function getInitialHoodAngleShooterUtils(totalHubDist, shooterLaunchSpeed) {
            if (totalHubDist <= 0.0 || shooterLaunchSpeed <= 0.0) {
                return null;
            }

            const speedSq = shooterLaunchSpeed * shooterLaunchSpeed;
            const distSq = totalHubDist * totalHubDist;
            const quadA = -4.9 * distSq / speedSq;
            const quadB = totalHubDist;
            const quadC = -4.9 * distSq / speedSq - DELTA_Z;

            const discriminant = quadB * quadB - 4 * quadA * quadC;
            if (Math.abs(quadA) < 1e-9 || discriminant < 0) {
                return null;
            }

            const sqrtDisc = Math.sqrt(discriminant);
            const root1 = (-quadB + sqrtDisc) / (2 * quadA);
            const root2 = (-quadB - sqrtDisc) / (2 * quadA);

            const angle1 = Math.atan(root1);
            const angle2 = Math.atan(root2);

            const validAngles = [angle1, angle2].filter(a => Number.isFinite(a) && a > 0.0 && a < Math.PI / 2);
            if (validAngles.length === 0) {
                return null;
            }

            return Math.max(...validAngles);
        }

        // Port of ShooterUtils.getFlightTime(totalHubDist, shooterLaunchSpeed, hoodAngle)
        function getFlightTimeShooterUtils(totalHubDist, shooterLaunchSpeed, hoodAngleRad) {
            const cosTerm = Math.cos(hoodAngleRad);
            if (shooterLaunchSpeed <= 0.0 || cosTerm <= 1e-9) {
                return 0.0;
            }
            return totalHubDist / (shooterLaunchSpeed * cosTerm);
        }

        // Port of ShooterUtils.getFinalHoodAngle(targetDist, shooterLaunchSpeed, flightTime)
        // Computes final hood angle from lead-adjusted target distance and clamps to allowed range.
        function getFinalHoodAngleShooterUtils(targetDist, shooterLaunchSpeed, flightTime) {
            const denom = shooterLaunchSpeed * flightTime;
            if (denom <= 1e-9) {
                return SHOOTER_MIN_ANGLE;
            }
            const cosArg = clamp(targetDist / denom, -1.0, 1.0);
            const rawAngleDeg = Math.acos(cosArg) * 180 / Math.PI;
            return clamp(rawAngleDeg, SHOOTER_MIN_ANGLE, SHOOTER_MAX_ANGLE);
        }

        // Simulator-specific: only inherit chassis velocity into shot when velocity motion is enabled.
        function getEffectiveRobotVelocity() {
            if (!state.velocityMotionEnabled) {
                return { vx: 0.0, vy: 0.0 };
            }
            return { vx: state.robotVx, vy: state.robotVy };
        }

        // Port of ShooterUtils.run() solve path:
        // 1) compute raw hub vector, 2) estimate flight time, 3) lead target by robot velocity,
        // 4) solve turret + hood command, 5) return debug-friendly intermediate values.
        function computeAutoShootCommand(robotVx, robotVy) {
            const xHubDistance = HUB_X - state.robotX;
            const yHubDistance = HUB_Y - state.robotY;
            const totalHubDist = Math.hypot(xHubDistance, yHubDistance);

            const shooterLaunchSpeed = getLaunchSpeedShooterUtils(totalHubDist);
            const initialHoodAngle = getInitialHoodAngleShooterUtils(totalHubDist, shooterLaunchSpeed)
                ?? (65.0 * Math.PI / 180);
            const flightTime = getFlightTimeShooterUtils(totalHubDist, shooterLaunchSpeed, initialHoodAngle);

            const targetXLocation = xHubDistance - robotVx * flightTime;
            const targetYLocation = yHubDistance - robotVy * flightTime;
            const targetDist = Math.hypot(targetXLocation, targetYLocation) + (0.3 * flightTime);

            const turretAngleDeg = Math.atan2(targetYLocation, targetXLocation) * 180 / Math.PI;
            const finalHoodAngleDeg = getFinalHoodAngleShooterUtils(targetDist, shooterLaunchSpeed, flightTime);

            return {
                velocity: shooterLaunchSpeed,
                elevationDeg: finalHoodAngleDeg,
                initialHoodAngleDeg: initialHoodAngle * 180 / Math.PI,
                turretAngleDeg,
                absoluteAzimuth: turretAngleDeg * Math.PI / 180,
                flightTime,
                xHubDistance,
                yHubDistance,
                totalHubDist,
                targetXLocation,
                targetYLocation,
                targetDist,
                robotVx,
                robotVy
            };
        }

        // Unified shot command for preview/fire:
        // - AutoShoot ON: uses ShooterUtils-derived solve.
        // - AutoShoot OFF: uses manual slider values.
        function getShotCommand() {
            const dx = HUB_X - state.robotX;
            const dy = HUB_Y - state.robotY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const bearing = Math.atan2(dy, dx);
            const velocity = getEffectiveRobotVelocity();

            if (state.autoShootEnabled) {
                const auto = computeAutoShootCommand(velocity.vx, velocity.vy);
                state.lastAutoSolution = auto;
                return {
                    launchVelocity: auto.velocity,
                    elevationDeg: auto.elevationDeg,
                    absoluteAzimuth: auto.absoluteAzimuth,
                    distance,
                    bearing,
                    robotVx: velocity.vx,
                    robotVy: velocity.vy
                };
            }

            state.lastAutoSolution = null;
            return {
                launchVelocity: state.velocity,
                elevationDeg: state.elevation,
                absoluteAzimuth: bearing + state.azimuth * Math.PI / 180,
                distance,
                bearing,
                robotVx: velocity.vx,
                robotVy: velocity.vy
            };
        }

        // ==================== TEST RUNNER ====================

        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('test') === '1') {
            document.getElementById('test-panel').style.display = 'block';
            document.getElementById('sidebar').style.display = 'none';
            document.getElementById('top-bar').style.display = 'none';
            document.getElementById('canvas-container').style.display = 'none';

            loadPhysicsTestData()
                .then(data => runTests(data))
                .catch(err => {
                    document.getElementById('test-results').innerHTML = `<p>Error loading test data: ${err.message}</p>`;
                });
        }

        async function loadPhysicsTestData() {
            if (window.location.protocol === 'file:') {
                throw new Error('Open via a local web server (file:// blocks fetch). Try: python -m http.server 8000 and use /scripts/shot_simulator.html?test=1');
            }

            const candidates = [
                'physics_test_data.json',
                './physics_test_data.json',
                '/scripts/physics_test_data.json'
            ];

            let lastError = null;
            for (const path of candidates) {
                try {
                    const response = await fetch(path, { cache: 'no-store' });
                    if (!response.ok) {
                        throw new Error(`${path} returned ${response.status}`);
                    }
                    return await response.json();
                } catch (err) {
                    lastError = err;
                }
            }

            throw new Error(`Could not load physics test data. Last error: ${lastError?.message || lastError}`);
        }

            // Runs in-browser regression tests against deterministic expected values.
        function runTests(testData) {
            const results = [];
            const caseResults = {};  // Store results by name for comparison tests

            // Run test_cases
            for (const test of testData.test_cases) {
                let passed = false;
                let details = '';

                try {
                    if (test.function === 'checkHubEntry') {
                        const result = checkHubEntry(test.params.height, test.params.vy);
                        const hitMatch = result.hit === test.expected.hit;
                        let missMatch = true;
                        if (test.expected.miss_distance !== undefined) {
                            const tol = (test.tolerance && test.tolerance.miss_distance) || 0.01;
                            missMatch = Math.abs(result.miss_distance - test.expected.miss_distance) < tol;
                        }
                        passed = hitMatch && missMatch;
                        details = `hit: ${result.hit} (exp ${test.expected.hit})`;
                        if (test.expected.miss_distance !== undefined) {
                            details += `, miss: ${result.miss_distance.toFixed(3)} (exp ${test.expected.miss_distance.toFixed(3)})`;
                        }
                    } else if (test.function === 'computeOptimalAngle') {
                        const result = computeOptimalAngle(test.params.velocity, test.params.target_distance);
                        const reachableMatch = result.reachable === test.expected.reachable;
                        let angleMatch = true;
                        if (result.reachable && test.expected.angle_deg !== undefined) {
                            const tol = (test.tolerance && test.tolerance.angle_deg) || 0.5;
                            angleMatch = Math.abs(result.angle_deg - test.expected.angle_deg) < tol;
                        }
                        passed = reachableMatch && angleMatch;
                        details = `reachable: ${result.reachable} (exp ${test.expected.reachable})`;
                        if (result.reachable && test.expected.angle_deg !== undefined) {
                            details += `, angle: ${result.angle_deg.toFixed(1)} (exp ${test.expected.angle_deg.toFixed(1)})`;
                        }
                    } else if (test.function === 'computeTrajectory3DMoving') {
                        const p = test.params;
                        const result = computeTrajectory3DMoving(
                            p.launch_velocity,
                            p.elevation_deg * Math.PI / 180,
                            p.azimuth_deg * Math.PI / 180,
                            p.target_distance,
                            p.target_bearing_deg * Math.PI / 180,
                            p.robot_vx || 0,
                            p.robot_vy || 0,
                            0.001,
                            p.air_resistance || false
                        );

                        // Store for comparison tests
                        // Also compute max_z for comparison
                        result.max_z = Math.max(...result.trajectory_z);
                        caseResults[test.name] = result;

                        const failures = [];
                        for (const [key, expected] of Object.entries(test.expected)) {
                            if (key === 'trajectory_length') continue;  // Skip array length comparison
                            const tol = (test.tolerance && test.tolerance[key]) || 0.05;
                            if (typeof expected === 'boolean') {
                                if (result[key] !== expected) {
                                    failures.push(`${key}: ${result[key]} != ${expected}`);
                                }
                            } else if (typeof expected === 'number') {
                                const actual = (key === 'start_z') ? result.trajectory_z[0] :
                                              (key === 'max_z') ? result.max_z :
                                              result[key];
                                if (actual === undefined) {
                                    failures.push(`${key}: undefined (exp ${expected})`);
                                } else if (Math.abs(actual - expected) >= tol) {
                                    failures.push(`${key}: ${actual.toFixed(4)} != ${expected.toFixed(4)} (tol ${tol})`);
                                }
                            }
                        }
                        passed = failures.length === 0;
                        details = passed ? `hit=${result.hit}, h=${result.height_at_target.toFixed(3)}` :
                                          failures.join('; ');
                    }
                } catch (err) {
                    passed = false;
                    details = `Error: ${err.message}`;
                }

                results.push({ name: test.name, passed, details });
            }

            // Run comparison tests
            if (testData.comparisons) {
                for (const comp of testData.comparisons) {
                    let passed = false;
                    let details = '';

                    try {
                        const resultA = caseResults[comp.case_a];
                        const resultB = caseResults[comp.case_b];

                        if (!resultA || !resultB) {
                            details = `Missing case: ${!resultA ? comp.case_a : comp.case_b}`;
                        } else {
                            const valA = comp.field === 'max_z' ? resultA.max_z : resultA[comp.field];
                            const valB = comp.field === 'max_z' ? resultB.max_z : resultB[comp.field];

                            if (comp.type === 'less_than') {
                                passed = valA < valB;
                                details = `${comp.case_a}.${comp.field} (${valA.toFixed(3)}) < ${comp.case_b}.${comp.field} (${valB.toFixed(3)})`;
                            } else if (comp.type === 'greater_than') {
                                passed = valA > valB;
                                details = `${comp.case_a}.${comp.field} (${valA.toFixed(3)}) > ${comp.case_b}.${comp.field} (${valB.toFixed(3)})`;
                            }
                            details += ` — ${comp.description}`;
                        }
                    } catch (err) {
                        details = `Error: ${err.message}`;
                    }

                    results.push({ name: comp.name, passed, details });
                }
            }

            const passCount = results.filter(r => r.passed).length;
            const totalCount = results.length;

            const resultsHtml = results.map(r => `
                <div class="test-result ${r.passed ? 'pass' : 'fail'}">
                    <div class="test-name">${r.passed ? '✓' : '✗'} ${r.name}</div>
                    <div class="test-details">${r.details}</div>
                </div>
            `).join('');

            document.getElementById('test-results').innerHTML = resultsHtml;
            document.getElementById('test-summary').textContent = `${passCount}/${totalCount} tests passed`;
            document.getElementById('test-summary').style.color = passCount === totalCount ? '#00cc44' : '#cc2200';
        }

        // ==================== THREE.JS SCENE SETUP ====================

        if (urlParams.get('test') !== '1') {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(2, 5, -3);
            camera.lookAt(2.5, 0.5, 4);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(4, 1, 4);
            controls.update();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 15, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Ground — just the alliance zone + margin past the hub
            const GROUND_DEPTH = ALLIANCE_ZONE_DEPTH + 1.5;  // past hub
            const GROUND_WIDTH = ALLIANCE_ZONE_WIDTH;
            const groundGeometry = new THREE.PlaneGeometry(GROUND_DEPTH, GROUND_WIDTH);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x4a7c59 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(GROUND_DEPTH / 2, 0, GROUND_WIDTH / 2);
            ground.receiveShadow = true;
            scene.add(ground);

            // Alliance zone boundary line
            const zoneBorder = new THREE.LineSegments(
                new THREE.EdgesGeometry(new THREE.PlaneGeometry(ALLIANCE_ZONE_DEPTH, ALLIANCE_ZONE_WIDTH)),
                new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 })
            );
            zoneBorder.rotation.x = -Math.PI / 2;
            zoneBorder.position.set(ALLIANCE_ZONE_DEPTH / 2, 0.003, ALLIANCE_ZONE_WIDTH / 2);
            scene.add(zoneBorder);

            // Grid lines (1m spacing)
            const gridMat = new THREE.LineBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.3 });
            const gridPoints = [];
            for (let x = 0; x <= GROUND_DEPTH; x += 1) {
                gridPoints.push(new THREE.Vector3(x, 0.002, 0), new THREE.Vector3(x, 0.002, GROUND_WIDTH));
            }
            for (let z = 0; z <= GROUND_WIDTH; z += 1) {
                gridPoints.push(new THREE.Vector3(0, 0.002, z), new THREE.Vector3(GROUND_DEPTH, 0.002, z));
            }
            const gridGeom = new THREE.BufferGeometry().setFromPoints(gridPoints);
            scene.add(new THREE.LineSegments(gridGeom, gridMat));

            // HUB
            const hubGeometry = new THREE.CylinderGeometry(0.53, 0.53, 1.83, 32);
            const hubMaterial = new THREE.MeshLambertMaterial({ color: 0x999999, transparent: true, opacity: 0.5 });
            const hub = new THREE.Mesh(hubGeometry, hubMaterial);
            hub.position.set(HUB_X, 1.83 / 2, HUB_Y);
            scene.add(hub);

            const ringGeometry = new THREE.TorusGeometry(0.53, 0.03, 16, 32);
            const ringMaterial = new THREE.MeshLambertMaterial({ color: 0xff8800 });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.set(HUB_X, 1.83, HUB_Y);
            ring.rotation.x = Math.PI / 2;
            scene.add(ring);

            // Robot
            const robot = new THREE.Group();
            const chassisGeometry = new THREE.BoxGeometry(0.5, 0.25, 0.5);
            const chassisMaterial = new THREE.MeshLambertMaterial({ color: 0x0066cc });
            const chassis = new THREE.Mesh(chassisGeometry, chassisMaterial);
            chassis.castShadow = true;
            robot.add(chassis);

            const barrelGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.3, 16);
            const barrelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.position.set(0, 0, 0);
            robot.add(barrel);

            scene.add(robot);

            // Ball
            const ballGeometry = new THREE.SphereGeometry(0.075, 16, 16);
            const ballMaterial = new THREE.MeshLambertMaterial({ color: 0xff6600 });
            const ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.visible = false;
            ball.castShadow = true;
            scene.add(ball);

            // Trajectory preview line (pre-allocated)
            const maxPoints = 600;
            const previewPositions = new Float32Array(maxPoints * 3);
            const previewGeometry = new THREE.BufferGeometry();
            previewGeometry.setAttribute('position', new THREE.BufferAttribute(previewPositions, 3));
            previewGeometry.setDrawRange(0, 0);
            const previewMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
            const previewLine = new THREE.Line(previewGeometry, previewMaterial);
            scene.add(previewLine);

            // Bearing line (dashed)
            const bearingGeometry = new THREE.BufferGeometry();
            bearingGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3));
            const bearingMaterial = new THREE.LineDashedMaterial({ color: 0xffff00, dashSize: 0.1, gapSize: 0.05 });
            const bearingLine = new THREE.Line(bearingGeometry, bearingMaterial);
            scene.add(bearingLine);

            // Landing marker
            const markerGeometry = new THREE.RingGeometry(0.05, 0.1, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
            const landingMarker = new THREE.Mesh(markerGeometry, markerMaterial);
            landingMarker.rotation.x = -Math.PI / 2;
            landingMarker.visible = false;
            scene.add(landingMarker);

            // ==================== STATE ====================

            // Central mutable simulator state.
            state = {
                robotX: ALLIANCE_ZONE_DEPTH / 2,
                robotY: ALLIANCE_ZONE_WIDTH / 2,
                robotVx: 0.1,
                robotVy: 0.1,
                velocityMotionEnabled: false,
                wallReflectionEnabled: true,
                autoShootEnabled: false,
                velocity: 15.0,
                elevation: 45.0,
                azimuth: 0.0,
                airResistance: true,
                dragCoeff: DRAG_COEFFICIENT_DEFAULT,
                ballMass: BALL_MASS_DEFAULT,
                firing: false,
                fireProgress: 0,
                totalShots: 0,
                hits: 0,
                lastTrajectory: null,
                lastHit: null,
                lastAutoSolution: null,
                lastMissReason: '',
                lastFrameTimeMs: null,
                keysPressed: new Set()
            };

            // ==================== UI UPDATES ====================

            // Refreshes sidebar telemetry and autoshoot debug output.
            function updateRobotInfo() {
                const dx = HUB_X - state.robotX;
                const dy = HUB_Y - state.robotY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const bearing = Math.atan2(dy, dx) * 180 / Math.PI;

                document.getElementById('robot-x').textContent = state.robotX.toFixed(2);
                document.getElementById('robot-y').textContent = state.robotY.toFixed(2);
                document.getElementById('robot-vx').textContent = state.robotVx.toFixed(2);
                document.getElementById('robot-vy').textContent = state.robotVy.toFixed(2);
                document.getElementById('optimal-distance').textContent = distance.toFixed(2);
                document.getElementById('optimal-bearing').textContent = bearing.toFixed(1);
                document.getElementById('shot-mode').textContent = state.autoShootEnabled ? 'AutoShoot' : 'Manual';

                const hitRate = state.totalShots > 0 ? (state.hits / state.totalShots * 100).toFixed(1) : 0;
                document.getElementById('shot-counter').textContent = `${state.hits}/${state.totalShots} (${hitRate}%)`;

                if (state.lastMissReason) {
                    document.getElementById('miss-reason-display').textContent = state.lastMissReason;
                } else {
                    document.getElementById('miss-reason-display').textContent = '';
                }

                const debugElement = document.getElementById('autoshoot-debug');
                if (!state.autoShootEnabled || !state.lastAutoSolution) {
                    debugElement.textContent = 'AutoShoot disabled.';
                } else {
                    const s = state.lastAutoSolution;
                    debugElement.textContent =
                        `robot_vx=${s.robotVx.toFixed(3)} m/s\n`
                        + `robot_vy=${s.robotVy.toFixed(3)} m/s\n`
                        + `x_hub=${s.xHubDistance.toFixed(3)} m\n`
                        + `y_hub=${s.yHubDistance.toFixed(3)} m\n`
                        + `dist_hub=${s.totalHubDist.toFixed(3)} m\n`
                        + `flight_time=${s.flightTime.toFixed(3)} s\n`
                        + `target_x=${s.targetXLocation.toFixed(3)} m\n`
                        + `target_y=${s.targetYLocation.toFixed(3)} m\n`
                        + `target_dist=${s.targetDist.toFixed(3)} m\n`
                        + `launch_v=${s.velocity.toFixed(3)} m/s\n`
                        + `hood_init=${s.initialHoodAngleDeg.toFixed(3)} deg\n`
                        + `hood_final=${s.elevationDeg.toFixed(3)} deg\n`
                        + `turret=${s.turretAngleDeg.toFixed(3)} deg`;
                }
            }

            // Recomputes and redraws the cyan preview line using current command + state.
            function updatePreview() {
                const shot = getShotCommand();

                const result = computeTrajectory3DMoving(
                    shot.launchVelocity,
                    shot.elevationDeg * Math.PI / 180,
                    shot.absoluteAzimuth,
                    shot.distance,
                    shot.bearing,
                    shot.robotVx,
                    shot.robotVy,
                    0.001,
                    state.airResistance,
                    state.dragCoeff,
                    state.ballMass
                );

                // Update preview line (sample every 10th point)
                const positions = previewGeometry.attributes.position.array;
                let idx = 0;
                for (let i = 0; i < result.trajectory_x.length && idx < maxPoints; i += 10) {
                    const fieldX = state.robotX + result.trajectory_x[i];
                    const fieldY = state.robotY + result.trajectory_y[i];
                    const fieldZ = result.trajectory_z[i];
                    positions[idx * 3] = fieldX;
                    positions[idx * 3 + 1] = fieldZ;
                    positions[idx * 3 + 2] = fieldY;
                    idx++;
                }
                previewGeometry.setDrawRange(0, idx);
                previewGeometry.attributes.position.needsUpdate = true;

                // Update barrel orientation
                barrel.rotation.z = -shot.elevationDeg * Math.PI / 180;
                const elevRad = shot.elevationDeg * Math.PI / 180;
                barrel.position.set(
                    Math.sin(elevRad) * 0.15,
                    Math.cos(elevRad) * 0.15,
                    0
                );

                robot.rotation.y = shot.absoluteAzimuth;

                // Update bearing line
                const bearingPos = bearingGeometry.attributes.position.array;
                bearingPos[0] = state.robotX;
                bearingPos[1] = 0.01;
                bearingPos[2] = state.robotY;
                bearingPos[3] = HUB_X;
                bearingPos[4] = 0.01;
                bearingPos[5] = HUB_Y;
                bearingGeometry.attributes.position.needsUpdate = true;
                bearingLine.computeLineDistances();

                updateRobotInfo();
            }

            // Fires one shot, records hit/miss statistics, and starts trajectory animation.
            function fireShot() {
                if (state.firing) return;

                const shot = getShotCommand();

                const result = computeTrajectory3DMoving(
                    shot.launchVelocity,
                    shot.elevationDeg * Math.PI / 180,
                    shot.absoluteAzimuth,
                    shot.distance,
                    shot.bearing,
                    shot.robotVx,
                    shot.robotVy,
                    0.001,
                    state.airResistance,
                    state.dragCoeff,
                    state.ballMass
                );

                state.lastTrajectory = result;
                state.lastHit = result.hit;
                state.lastMissReason = result.miss_reason || '';
                state.totalShots++;
                if (result.hit) state.hits++;

                state.firing = true;
                state.fireProgress = 0;

                // Change preview line color
                if (result.hit) {
                    previewMaterial.color.setHex(0x00cc44);
                    ring.material.color.setHex(0x00cc44);
                } else {
                    previewMaterial.color.setHex(0xcc2200);
                    ring.material.color.setHex(0xcc2200);
                }

                // Show landing marker
                if (result.trajectory_x.length > 0) {
                    let descIdx = -1;
                    for (let i = 1; i < result.trajectory_z.length; i++) {
                        if (result.trajectory_z[i - 1] >= HUB_OPENING_HEIGHT && result.trajectory_z[i] < HUB_OPENING_HEIGHT) {
                            descIdx = i;
                            break;
                        }
                    }
                    if (descIdx > 0) {
                        const landX = state.robotX + result.trajectory_x[descIdx];
                        const landY = state.robotY + result.trajectory_y[descIdx];
                        landingMarker.position.set(landX, HUB_OPENING_HEIGHT, landY);
                        landingMarker.material.color.setHex(result.hit ? 0x00cc44 : 0xcc2200);
                        landingMarker.visible = true;
                    }
                }

                updateRobotInfo();
                updateStatusIndicator();
            }

            // Updates top-bar status indicator: Ready / HIT / MISS.
            function updateStatusIndicator() {
                const statusDot = document.querySelector('.status-dot');
                const statusText = document.getElementById('status-text');

                if (state.lastHit === null) {
                    statusDot.className = 'status-dot neutral';
                    statusText.textContent = 'Ready';
                } else if (state.lastHit) {
                    statusDot.className = 'status-dot hit';
                    statusText.textContent = 'HIT';
                } else {
                    statusDot.className = 'status-dot miss';
                    statusText.textContent = 'MISS';
                }
            }

            // Re-centers robot in alliance zone and refreshes preview solution.
            function resetRobotPosition() {
                state.robotX = ALLIANCE_ZONE_DEPTH / 2;
                state.robotY = ALLIANCE_ZONE_WIDTH / 2;
                robot.position.set(state.robotX, 0.125, state.robotY);
                updatePreview();
            }

            // Disables manual aim controls while autoshoot is active to avoid conflicting inputs.
            function updateManualControlsState() {
                const manualSection = document.getElementById('manual-controls-section');
                const isDisabled = state.autoShootEnabled;

                document.getElementById('velocity-slider').disabled = isDisabled;
                document.getElementById('elevation-slider').disabled = isDisabled;
                document.getElementById('azimuth-slider').disabled = isDisabled;

                manualSection.classList.toggle('disabled', isDisabled);
            }

            // ==================== EVENT HANDLERS ====================

            document.getElementById('velocity-slider').addEventListener('input', (e) => {
                state.velocity = parseFloat(e.target.value);
                document.getElementById('velocity-value').textContent = state.velocity.toFixed(1);
                previewMaterial.color.setHex(0x00ffff);
                updatePreview();
            });

            document.getElementById('elevation-slider').addEventListener('input', (e) => {
                state.elevation = parseFloat(e.target.value);
                document.getElementById('elevation-value').textContent = state.elevation.toFixed(1);
                previewMaterial.color.setHex(0x00ffff);
                updatePreview();
            });

            document.getElementById('azimuth-slider').addEventListener('input', (e) => {
                state.azimuth = parseFloat(e.target.value);
                document.getElementById('azimuth-value').textContent = state.azimuth.toFixed(1);
                previewMaterial.color.setHex(0x00ffff);
                updatePreview();
            });

            document.getElementById('robot-vx-slider').addEventListener('input', (e) => {
                state.robotVx = parseFloat(e.target.value);
                document.getElementById('robot-vx-value').textContent = state.robotVx.toFixed(1);
                previewMaterial.color.setHex(0x00ffff);
                updatePreview();
            });

            document.getElementById('robot-vy-slider').addEventListener('input', (e) => {
                state.robotVy = parseFloat(e.target.value);
                document.getElementById('robot-vy-value').textContent = state.robotVy.toFixed(1);
                previewMaterial.color.setHex(0x00ffff);
                updatePreview();
            });

            document.getElementById('velocity-motion-checkbox').addEventListener('change', (e) => {
                state.velocityMotionEnabled = e.target.checked;
                if (state.velocityMotionEnabled) {
                    state.keysPressed.clear();
                }
                previewMaterial.color.setHex(0x00ffff);
                updatePreview();
            });

            document.getElementById('wall-reflection-checkbox').addEventListener('change', (e) => {
                state.wallReflectionEnabled = e.target.checked;
            });

            document.getElementById('autoshoot-checkbox').addEventListener('change', (e) => {
                state.autoShootEnabled = e.target.checked;
                updateManualControlsState();
                previewMaterial.color.setHex(0x00ffff);
                updatePreview();
            });

            document.getElementById('air-resistance-checkbox').addEventListener('change', (e) => {
                state.airResistance = e.target.checked;
                previewMaterial.color.setHex(0x00ffff);
                updatePreview();
            });

            document.getElementById('drag-coeff-slider').addEventListener('input', (e) => {
                state.dragCoeff = parseFloat(e.target.value);
                document.getElementById('drag-coeff-value').textContent = state.dragCoeff.toFixed(2);
                previewMaterial.color.setHex(0x00ffff);
                updatePreview();
            });

            document.getElementById('ball-mass-slider').addEventListener('input', (e) => {
                state.ballMass = parseFloat(e.target.value);
                document.getElementById('ball-mass-value').textContent = state.ballMass.toFixed(3);
                previewMaterial.color.setHex(0x00ffff);
                updatePreview();
            });


            window.addEventListener('keydown', (e) => {
                // Ignore key events when focused on inputs
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
                if (e.repeat) return;
                state.keysPressed.add(e.key.toLowerCase());

                if (e.key === ' ') {
                    e.preventDefault();
                    fireShot();
                } else if (e.key.toLowerCase() === 'r') {
                    resetRobotPosition();
                } else if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(e.key.toLowerCase())) {
                    e.preventDefault();  // Prevent page scrolling
                }
            });

            window.addEventListener('keyup', (e) => {
                state.keysPressed.delete(e.key.toLowerCase());
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // ==================== ANIMATION LOOP ====================

            // Per-frame loop: integrates robot motion, handles reflection/manual driving,
            // animates fired ball, and renders scene.
            function animate() {
                requestAnimationFrame(animate);

                const nowMs = performance.now();
                const dtFrame = state.lastFrameTimeMs === null
                    ? 1.0 / 60.0
                    : Math.min(0.05, (nowMs - state.lastFrameTimeMs) / 1000.0);
                state.lastFrameTimeMs = nowMs;

                // Handle movement keys
                const moveSpeed = 0.05;
                let moved = false;

                if (state.velocityMotionEnabled) {
                    state.robotX += state.robotVx * dtFrame;
                    state.robotY += state.robotVy * dtFrame;

                    const xMin = 0.1;
                    const xMax = ALLIANCE_ZONE_DEPTH - 0.1;
                    const yMin = 0.1;
                    const yMax = ALLIANCE_ZONE_WIDTH - 0.1;

                    if (state.wallReflectionEnabled) {
                        if (state.robotX <= xMin) {
                            state.robotX = xMin;
                            state.robotVx = Math.abs(state.robotVx);
                            document.getElementById('robot-vx-slider').value = state.robotVx.toFixed(1);
                            document.getElementById('robot-vx-value').textContent = state.robotVx.toFixed(1);
                        } else if (state.robotX >= xMax) {
                            state.robotX = xMax;
                            state.robotVx = -Math.abs(state.robotVx);
                            document.getElementById('robot-vx-slider').value = state.robotVx.toFixed(1);
                            document.getElementById('robot-vx-value').textContent = state.robotVx.toFixed(1);
                        }

                        if (state.robotY <= yMin) {
                            state.robotY = yMin;
                            state.robotVy = Math.abs(state.robotVy);
                            document.getElementById('robot-vy-slider').value = state.robotVy.toFixed(1);
                            document.getElementById('robot-vy-value').textContent = state.robotVy.toFixed(1);
                        } else if (state.robotY >= yMax) {
                            state.robotY = yMax;
                            state.robotVy = -Math.abs(state.robotVy);
                            document.getElementById('robot-vy-slider').value = state.robotVy.toFixed(1);
                            document.getElementById('robot-vy-value').textContent = state.robotVy.toFixed(1);
                        }
                    } else {
                        state.robotX = clamp(state.robotX, xMin, xMax);
                        state.robotY = clamp(state.robotY, yMin, yMax);
                    }

                    moved = true;
                }

                if (!state.velocityMotionEnabled) {
                    if (state.keysPressed.has('w') || state.keysPressed.has('arrowup')) {
                        state.robotX = Math.min(state.robotX + moveSpeed, ALLIANCE_ZONE_DEPTH - 0.1);
                        moved = true;
                    }
                    if (state.keysPressed.has('s') || state.keysPressed.has('arrowdown')) {
                        state.robotX = Math.max(state.robotX - moveSpeed, 0.1);
                        moved = true;
                    }
                    if (state.keysPressed.has('a') || state.keysPressed.has('arrowleft')) {
                        state.robotY = Math.max(state.robotY - moveSpeed, 0.1);
                        moved = true;
                    }
                    if (state.keysPressed.has('d') || state.keysPressed.has('arrowright')) {
                        state.robotY = Math.min(state.robotY + moveSpeed, ALLIANCE_ZONE_WIDTH - 0.1);
                        moved = true;
                    }
                }

                if (moved) {
                    robot.position.set(state.robotX, 0.125, state.robotY);
                    previewMaterial.color.setHex(0x00ffff);
                    landingMarker.visible = false;
                    updatePreview();
                }

                // Animate ball during firing
                if (state.firing) {
                    state.fireProgress += 0.015;

                    if (state.fireProgress >= 1.0) {
                        state.firing = false;
                        state.fireProgress = 0;
                        ball.visible = false;

                        // Flash hub ring
                        setTimeout(() => {
                            ring.material.color.setHex(0xff8800);
                        }, 300);
                    } else {
                        const traj = state.lastTrajectory;
                        const idx = Math.floor(state.fireProgress * (traj.trajectory_x.length - 1));
                        const frac = state.fireProgress * (traj.trajectory_x.length - 1) - idx;
                        const next = Math.min(idx + 1, traj.trajectory_x.length - 1);

                        const lerp = (a, b, t) => a + (b - a) * t;
                        const x = lerp(traj.trajectory_x[idx], traj.trajectory_x[next], frac);
                        const y = lerp(traj.trajectory_y[idx], traj.trajectory_y[next], frac);
                        const z = lerp(traj.trajectory_z[idx], traj.trajectory_z[next], frac);

                        ball.position.set(state.robotX + x, z, state.robotY + y);
                        ball.visible = true;
                    }
                }

                controls.update();
                renderer.render(scene, camera);
            }

            // Initialize
            robot.position.set(state.robotX, 0.125, state.robotY);
            updateManualControlsState();
            updatePreview();
            animate();
        }
    </script>
</body>
</html>
